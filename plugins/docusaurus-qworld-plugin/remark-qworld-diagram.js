const visit = require('unist-util-visit');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');
const { execSync } = require('child_process');

const OUTPUT_BASE_DIR = 'static/img/qworld-diagrams'; // Relative to project root
const OUTPUT_SVG_DIR = path.join(process.cwd(), OUTPUT_BASE_DIR);
const LATEX_PLUGIN_DIR = path.join(process.cwd(), 'plugins/docusaurus-qworld-plugin/latex');
const TEMP_DIR = path.join(process.cwd(), '.qworld-temp');

function ensureDirExists(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

module.exports = function remarkQWorldDiagram() {
  ensureDirExists(OUTPUT_SVG_DIR);
  ensureDirExists(TEMP_DIR);

  return (tree) => {
    visit(tree, 'code', (node) => {
      if (node.lang === 'qworld-diagram') {
        const latexCode = node.value;
        const diagramHash = crypto.createHash('md5').update(latexCode).digest('hex');
        const svgFileName = `${diagramHash}.svg`;
        const svgFilePath = path.join(OUTPUT_SVG_DIR, svgFileName);
        const publicPath = `/${OUTPUT_BASE_DIR}/${svgFileName}`; // Path for the <img> tag

        // Check if SVG already exists (caching)
        if (fs.existsSync(svgFilePath)) {
          node.type = 'html';
          node.value = `<img src="${publicPath}" alt="QWorld Diagram">`;
          return;
        }

        // If not cached, proceed with compilation
        const tempTexFileName = `${diagramHash}.tex`;
        const tempPdfFileName = `${diagramHash}.pdf`;
        const tempTexFilePath = path.join(TEMP_DIR, tempTexFileName);
        const tempPdfFilePath = path.join(TEMP_DIR, tempPdfFileName);

        // LaTeX preamble for QWorld diagrams
        const latexPreamble = `
\documentclass{standalone}
\usepackage{tikz}
\usepackage{qworld}
\begin{document}
`;
        const latexPostamble = `
\end{document}
`;

        const fullLatexContent = latexPreamble + latexCode + latexPostamble;

        try {
          // 1. Copy qworld.sty to temp directory so LaTeX can find it
          fs.copyFileSync(path.join(LATEX_PLUGIN_DIR, 'qworld.sty'), path.join(TEMP_DIR, 'qworld.sty'));

          // 2. Write LaTeX code to a temporary .tex file
          fs.writeFileSync(tempTexFilePath, fullLatexContent);

          // 2. Compile LaTeX to PDF using pdflatex
          // -output-directory: specify output directory for generated files
          // -interaction=nonstopmode: do not stop for errors
          // -halt-on-error: stop on first error
          // -shell-escape: allow external commands (needed for some TikZ features, though not directly for qworld.sty)
          execSync(`lualatex -output-directory=${TEMP_DIR} -interaction=nonstopmode -halt-on-error ${tempTexFilePath}`, { stdio: 'inherit' });

          // 3. Convert PDF to SVG using pdf2svg
          execSync(`pdf2svg ${tempPdfFilePath} ${svgFilePath}`);

          // 4. Clean up temporary files
          fs.unlinkSync(tempTexFilePath);
          fs.unlinkSync(tempPdfFilePath);
          // Remove aux, log, etc. files generated by pdflatex
          fs.readdirSync(TEMP_DIR).forEach(file => {
            if (file.startsWith(diagramHash) && file !== svgFileName) {
              fs.unlinkSync(path.join(TEMP_DIR, file));
            }
          });

          node.type = 'html';
          node.value = `<img src="${publicPath}" alt="QWorld Diagram">`;
        } catch (error) {
          console.error(`Error compiling QWorld diagram (hash: ${diagramHash}): ${error.message}`);
          console.error(`LaTeX code: \n${latexCode}`);
          node.type = 'html';
          node.value = `<p style="color: red;">Error rendering QWorld diagram: ${error.message}</p><pre>${latexCode}</pre>`;
        }
      }
    });
  };
};